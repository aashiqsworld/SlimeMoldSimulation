
struct Agent
{
    float2 position;
    float angle;
};


RWTexture2D<float4> TrailMap;
RWTexture2D<float4> ProcessedTrailMap;

int width;
int height;

RWStructuredBuffer<Agent> agents;
int numAgents;

float moveSpeed;
float evaporateSpeed;
float diffuseRate;
float slimeTurnSpeed;

float time;
float deltaTime;

float sensorOffsetDist;
float sensorSize;
float sensorAngleDegrees;

Texture2D<float4> Gradient;
int gradientWidth;

uint hash(uint state)
{
    state ^= 2747636419u;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    state ^= state >> 16;
    state *= 2654435769u;
    return state;
}

float scaleToRange01(uint state)
{
    return state / 4294967295.0;
}

float sense(Agent agent, float sensorAngleOffset)
{
    float sensorAngle = agent.angle + sensorAngleOffset;
    float2 sensorDir = float2(cos(sensorAngle), sin(sensorAngle));

    float2 sensorPos = agent.position + sensorDir * sensorOffsetDist;
    int sensorCentreX = (int) sensorPos.x;
    int sensorCentreY = (int) sensorPos.y;

    float sum = 0;

    // int4 senseWeight = agent.speciesMask * 2 - 1;

    for (int offsetX = -sensorSize; offsetX <= sensorSize; offsetX ++) {
        for (int offsetY = -sensorSize; offsetY <= sensorSize; offsetY ++) {
            int sampleX = min(width - 1, max(0, sensorCentreX + offsetX));
            int sampleY = min(height - 1, max(0, sensorCentreY + offsetY));
            sum += TrailMap[int2(sampleX,sampleY)];
            // TrailMap[int2(sampleX,sampleY)] += float4(0,0,1,0);
        }
    }

    return sum;
}

#pragma kernel Update
[numthreads(32,1,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= numAgents) { return; }
    
    Agent agent = agents[id.x];

    float2 pos = agent.position;
    uint random = hash(pos.y * width + pos.x + hash(id.x + time * 100000));
    
    // Steer based on sensory data
    float sensorAngleRad = sensorAngleDegrees * (3.1415 / 180);
    float weightForward = sense(agent, 0);
    float weightLeft = sense(agent, sensorAngleRad);
    float weightRight = sense(agent, -sensorAngleRad);

    float randomSteerStrength = scaleToRange01(random);
    float turnSpeed = slimeTurnSpeed * 2 * 3.1415;

    // Continue in same direction
    if(weightForward > weightLeft && weightForward > weightRight)
    {
        agents[id.x].angle += 0;
    }
    else if (weightForward < weightLeft && weightForward < weightRight) {
        agents[id.x].angle += (randomSteerStrength - 0.5) * 2 * turnSpeed * deltaTime;
    }
    // Turn right
    else if (weightRight > weightLeft) {
        agents[id.x].angle -= randomSteerStrength * turnSpeed * deltaTime;
    }
    // Turn left
    else if (weightLeft > weightRight) {
        agents[id.x].angle += randomSteerStrength * turnSpeed * deltaTime;
    }
    
    // Move agent based on direction and speed
    float2 direction = float2(cos(agent.angle), sin(agent.angle));
    float2 newPos = agent.position + direction * moveSpeed * deltaTime;
    
    // Clamp position to map boundaries, and pick new random move angle if hit boundary
    if(newPos.x < 0 || newPos.x >= width || newPos.y < 0 || newPos.y >= height)
    {
        newPos.x = min(width-0.01, max(0, newPos.x));
        newPos.y = min(height-0.01, max(0, newPos.y));
        agents[id.x].angle = scaleToRange01(random) * 2 * 3.1415;
    }
    
    // Set new position and draw trail
    agents[id.x].position = newPos;
    
    TrailMap[int2(newPos.x, newPos.y)] = float4(1,1,1,1);
}

#pragma kernel ProcessTrailMap
[numthreads(8,8,1)]
void ProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    if(id.x < 0 || id.x >= width || id.y < 0 || id.y >= height)
    {
        return;
    }
    
    float4 sum = 0;
    float4 originalCol = TrailMap[id.xy];
    
    for (int offsetX = -1; offsetX <= 1; offsetX ++) {
        for (int offsetY = -1; offsetY <= 1; offsetY ++) {
            int sampleX = min(width-1, max(0, id.x + offsetX));
            int sampleY = min(height-1, max(0, id.y + offsetY));
            sum += TrailMap[int2(sampleX,sampleY)];
        }
    }

    float4 blurredCol = sum / 9;
    float diffuseWeight = saturate(diffuseRate * deltaTime);
    blurredCol = originalCol * (1 - diffuseWeight) + blurredCol * (diffuseWeight);

    TrailMap[id.xy] = max(0, blurredCol - evaporateSpeed * deltaTime);
}

#pragma kernel PostProcessTrailMap
[numthreads(8,8,1)]
void PostProcessTrailMap (uint3 id : SV_DispatchThreadID)
{
    float val = TrailMap[id.xy];
    float4 colorFromGradient = Gradient[uint2(val*gradientWidth , 1)];
    ProcessedTrailMap[id.xy] = colorFromGradient;

    
}